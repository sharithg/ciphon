package tools

import (
	"fmt"
	"log"
	"os"
	"reflect"
	"strings"
)

type TsField struct {
	Name      string
	FieldType string
	Nullable  bool
}

type TsType struct {
	Name   string
	Fields []TsField
}

type Parser struct {
	TsPrefix string
	TsFile   string
}

func NewGoToTs(tsPrefix, tsFile string) *Parser {
	return &Parser{
		TsPrefix: tsPrefix,
		TsFile:   tsFile,
	}
}

func (p *Parser) ToTs(structs []interface{}) error {
	var tsDefs strings.Builder

	fmt.Fprintf(&tsDefs, "%s\n\n", "// auto generated by go-ts, DO NOT EDIT")

	for _, s := range structs {
		tsType := p.parseStruct(s)
		fmt.Fprintf(&tsDefs, "%s\n", generateTsStruct(tsType))
	}

	// Write the TypeScript definitions to a file
	f, err := os.Create(p.TsFile)
	if err != nil {
		return fmt.Errorf("error creating ts file: %s", err)
	}
	defer f.Close()

	_, err = f.WriteString(tsDefs.String())
	if err != nil {
		return fmt.Errorf("error writing generated ts: %s", err)
	}

	return nil
}

func (p *Parser) parseStruct(s interface{}) TsType {
	t := reflect.TypeOf(s)
	tsType := TsType{
		Name: fmt.Sprintf("%s%s", p.TsPrefix, t.Name()),
	}

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tsField := TsField{
			Name:      field.Name,
			FieldType: goToTSType(field.Type.String()),
		}

		if jsonTag, nullable := parseJSONTag(field.Tag); jsonTag != "" {
			tsField.Name = jsonTag
			tsField.Nullable = nullable
		} else {
			log.Printf("field %s in struct %s does not have a JSON tag\n", tsField.Name, tsType.Name)
		}

		tsType.Fields = append(tsType.Fields, tsField)
	}

	return tsType
}

func generateTsStruct(tsType TsType) string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "export type %s = {\n", tsType.Name)

	for _, field := range tsType.Fields {
		fieldType := field.FieldType
		fieldName := field.Name
		if field.Nullable {
			fieldName += "?"
		}
		fmt.Fprintf(&sb, "  %s: %s;\n", fieldName, fieldType)
	}
	sb.WriteString("};\n")
	return sb.String()
}

func goToTSType(goType string) string {
	goType = strings.Replace(goType, "*", "", -1)

	switch {
	case strings.HasPrefix(goType, "int"), strings.HasPrefix(goType, "float"):
		return "number"
	case strings.HasPrefix(goType, "[]int"), strings.HasPrefix(goType, "[]float"):
		return "number[]"
	case strings.HasPrefix(goType, "[]string"):
		return "string[]"
	case goType == "string":
		return "string"
	case goType == "bool":
		return "boolean"
	case goType == "[]byte":
		return "Uint8Array"
	case goType == "map[string]interface{}":
		return "{ [key: string]: any }"
	case goType == "interface{}":
		return "any"
	case goType == "time.Time":
		return "string"
	case goType == "uuid.UUID":
		return "string"
	default:
		log.Printf("warning: unhandled Go type '%s', defaulting to 'unknown'", goType)
		return "unknown"
	}
}

func parseJSONTag(tag reflect.StructTag) (string, bool) {
	structTag := reflect.StructTag(tag)
	jsonTag := structTag.Get("json")

	if jsonTag == "" {
		return "", false
	}

	parts := strings.Split(jsonTag, ",")
	omitempty := false
	for _, part := range parts[1:] {
		if part == "omitempty" {
			omitempty = true
			break
		}
	}

	return parts[0], omitempty
}
